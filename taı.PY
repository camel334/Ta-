import sys
import time
import subprocess  # Paket yÃ¼kleme iÃ§in eklendi
from pypresence import Presence  # Discord RPC iÃ§in eklendi
import pyautogui
import google.generativeai as genai
from PIL import Image
from PyQt5.QtCore import Qt, QTimer, QObject, pyqtSignal, QPropertyAnimation, QEasingCurve, QSize
from PyQt5.QtGui import QImage, QPixmap, QColor, QFont, QIcon, QPainter, QPainterPath, QBrush, QPen
from PyQt5.QtWidgets import (QApplication, QWidget, QPushButton, QLabel, QVBoxLayout, QHBoxLayout, 
                           QLineEdit, QFileDialog, QTextEdit, QGraphicsDropShadowEffect, 
                           QSizePolicy, QFrame, QScrollArea, QCheckBox, QDialog, QMessageBox,
                           QGraphicsOpacityEffect, QSpacerItem)
import threading
import os
import datetime
import requests
from bs4 import BeautifulSoup
import re  # DÃ¼zenli ifadeler iÃ§in
import shutil  # Dosya iÅŸlemleri iÃ§in
import json  # ZamanlanmÄ±ÅŸ gÃ¶revler iÃ§in eklendi

# Gerekli paketleri kontrol et ve eksik olanlarÄ± yÃ¼kle
def check_and_install_packages():
    packages = [
        "pyautogui",
        "google-generativeai",
        "pillow",
        "PyQt5"
    ]
    
    for package in packages:
        try:
            if package == "pillow":
                __import__("PIL")
            elif package == "PyQt5":
                __import__("PyQt5")
            elif package == "google-generativeai":
                __import__("google.generativeai")
            else:
                __import__(package)
            print(f"{package} zaten yÃ¼klÃ¼.")
        except ImportError:
            print(f"{package} bulunamadÄ±, yÃ¼kleniyor...")
            try:
                subprocess.run([sys.executable, "-m", "pip", "install", package], check=True)
                print(f"{package} baÅŸarÄ±yla yÃ¼klendi.")
            except subprocess.CalledProcessError:
                print(f"{package} yÃ¼klenirken hata oluÅŸtu!")

# Uygulama baÅŸlamadan Ã¶nce paketleri kontrol et
check_and_install_packages()

# API anahtarÄ± diyalogu
class APIKeyDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Gemini API AnahtarÄ±")
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
        self.setStyleSheet("""
            QDialog {
                background-color: #282a36;
                color: white;
                font-family: 'Segoe UI', 'Arial';
            }
            QLabel {
                color: white;
                font-size: 14px;
            }
            QLineEdit {
                background-color: #383850;
                color: white;
                border: 1px solid #44445a;
                border-radius: 8px;
                padding: 12px;
                font-size: 14px;
            }
            QLineEdit:focus {
                border: 1px solid #6272a4;
            }
            QPushButton {
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: bold;
                color: white;
                font-size: 14px;
            }
            QPushButton#okButton {
                background-color: #50fa7b;
                color: #282a36;
            }
            QPushButton#okButton:hover {
                background-color: #5af78e;
            }
            QPushButton#cancelButton {
                background-color: #ff5555;
            }
            QPushButton#cancelButton:hover {
                background-color: #ff6e6e;
            }
            QTextEdit {
                background-color: #383850;
                color: white;
                border-radius: 8px;
                padding: 12px;
                font-size: 13px;
                border: 1px solid #44445a;
            }
        """)
        
        self.api_key = ""
        self.initUI()
        
    def initUI(self):
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # BaÅŸlÄ±k ve aÃ§Ä±klama
        title_label = QLabel("Gemini API AnahtarÄ±nÄ± Girin")
        title_label.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(title_label)
        
        info_label = QLabel("TAI'yi kullanmak iÃ§in Google Gemini API anahtarÄ± gereklidir. "
                          "EÄŸer API anahtarÄ±nÄ±z yoksa aÅŸaÄŸÄ±daki adÄ±mlarÄ± izleyebilirsiniz.")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # API anahtarÄ± alanÄ±
        key_layout = QVBoxLayout()
        key_layout.setSpacing(8)
        key_label = QLabel("API AnahtarÄ±:")
        key_label.setStyleSheet("font-weight: bold;")
        self.key_input = QLineEdit()
        self.key_input.setPlaceholderText("Gemini API anahtarÄ±nÄ±zÄ± buraya yapÄ±ÅŸtÄ±rÄ±n")
        key_layout.addWidget(key_label)
        key_layout.addWidget(self.key_input)
        layout.addLayout(key_layout)
        
        # API anahtarÄ± alma talimatlarÄ±
        instructions = QTextEdit()
        instructions.setReadOnly(True)
        instructions.setText("API AnahtarÄ± Alma AdÄ±mlarÄ±:\n\n"
                             "1. https://aistudio.google.com/app/apikey adresine gidin\n"
                             "2. Google hesabÄ±nÄ±zla giriÅŸ yapÄ±n\n"
                             "3. 'Create API Key' butonuna tÄ±klayÄ±n\n"
                             "4. OluÅŸturulan API anahtarÄ±nÄ± kopyalayÄ±n\n"
                             "5. YukarÄ±daki alana yapÄ±ÅŸtÄ±rÄ±n\n\n"
                             "API anahtarÄ±nÄ±z gÃ¼venle saklanacaktÄ±r.")
        instructions.setFixedHeight(150)
        layout.addWidget(instructions)
        
        # Butonlar
        button_layout = QHBoxLayout()
        self.ok_button = QPushButton("Tamam")
        self.ok_button.setObjectName("okButton")
        self.ok_button.clicked.connect(self.accept_key)
        self.cancel_button = QPushButton("Ä°ptal")
        self.cancel_button.setObjectName("cancelButton")
        self.cancel_button.clicked.connect(self.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(self.cancel_button)
        button_layout.addWidget(self.ok_button)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
        self.resize(450, 450)
        
    def accept_key(self):
        self.api_key = self.key_input.text().strip()
        if not self.api_key:
            QMessageBox.warning(self, "UyarÄ±", "API anahtarÄ± boÅŸ olamaz!")
            return
        
        # Minimal API anahtarÄ± kontrolÃ¼ (format ve uzunluk kontrolÃ¼)
        if not self.api_key.startswith("AIza") or len(self.api_key) < 30:
            response = QMessageBox.warning(
                self, 
                "GeÃ§ersiz API AnahtarÄ±", 
                "GirdiÄŸiniz API anahtarÄ± geÃ§ersiz gÃ¶rÃ¼nÃ¼yor. Devam etmek istiyor musunuz?", 
                QMessageBox.Yes | QMessageBox.No
            )
            if response == QMessageBox.No:
                return
        
        self.accept()

# Gemini API anahtarÄ±
GEMINI_API_KEY = ""

# UI gÃ¼ncellemesi iÃ§in sinyal sÄ±nÄ±fÄ±
class UISignals(QObject):
    update_ui = pyqtSignal(object)
    show_error = pyqtSignal(object, object)

class ChatMessage(QFrame):
    def __init__(self, text, is_user=False, parent=None):
        super().__init__(parent)
        self.setObjectName("chatMessage")
        self.is_user = is_user
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 10, 15, 10)
        
        # KullanÄ±cÄ± mesajÄ±nÄ± saÄŸa, AI mesajÄ±nÄ± sola hizala
        message_layout = QHBoxLayout()
        message_layout.setContentsMargins(0, 0, 0, 0)
        
        # Mesaj iÃ§eriÄŸi iÃ§in Ã§erÃ§eve
        self.content_frame = QFrame(self)
        self.content_frame.setObjectName("messageContentFrame")
        content_layout = QVBoxLayout(self.content_frame)
        content_layout.setContentsMargins(12, 8, 12, 8)
        
        # Mesaj metni
        self.message = QTextEdit()
        self.message.setReadOnly(True)
        self.message.setPlainText(text)
        self.message.setObjectName("messageText")
        self.message.setFrameStyle(QFrame.NoFrame)
        self.message.setMinimumHeight(30)
        self.message.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
        self.message.document().setDocumentMargin(2)
        self.message.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        content_layout.addWidget(self.message)
        
        # KullanÄ±cÄ± mesajÄ±nÄ± saÄŸa, AI mesajÄ±nÄ± sola hizala
        if is_user:
            message_layout.addStretch(1)
            self.content_frame.setStyleSheet("""
                QFrame#messageContentFrame {
                    background-color: #4285f4;
                    border-radius: 15px;
                    border-top-right-radius: 5px;
                }
                QTextEdit#messageText {
                    background-color: transparent;
                    color: white;
                    font-size: 15px;
                    border: none;
                }
            """)
        else:
            self.content_frame.setStyleSheet("""
                QFrame#messageContentFrame {
                    background-color: #444654;
                    border-radius: 15px;
                    border-top-left-radius: 5px;
                }
                QTextEdit#messageText {
                    background-color: transparent;
                    color: white;
                    font-size: 15px;
                    border: none;
                }
            """)
            message_layout.addStretch(1)
        
        # Mesaj Ã§erÃ§evesini maksimum geniÅŸliÄŸe ayarla
        self.content_frame.setMaximumWidth(600)
        message_layout.addWidget(self.content_frame)
        layout.addLayout(message_layout)

# ZamanlanmÄ±ÅŸ gÃ¶revler yÃ¶neticisi sÄ±nÄ±fÄ±
class ScheduledTaskManager:
    def __init__(self, parent=None):
        self.parent = parent
        self.tasks = []  # GÃ¶revleri saklayacak liste
        self.task_file = os.path.join(os.path.expanduser("~"), ".tai_tasks.json")
        self.load_tasks()  # KaydedilmiÅŸ gÃ¶revleri yÃ¼kle
        
        # ZamanlayÄ±cÄ± oluÅŸtur ve dakikada bir kontrol et
        self.timer = QTimer(parent)
        self.timer.timeout.connect(self.check_tasks)
        self.timer.start(60000)  # 60 saniye = 1 dakika
        
        # AnlÄ±k gÃ¶revler iÃ§in zamanlayÄ±cÄ±
        self.immediate_timer = QTimer(parent)
        self.immediate_timer.timeout.connect(self.check_immediate_tasks)
        self.immediate_timer.start(1000)  # Her saniye kontrol et
        
        # AnlÄ±k gÃ¶revler listesi
        self.immediate_tasks = []
    
    def load_tasks(self):
        # KayÄ±tlÄ± gÃ¶revleri dosyadan yÃ¼kle
        if os.path.exists(self.task_file):
            try:
                with open(self.task_file, 'r') as f:
                    self.tasks = json.load(f)
                print(f"{len(self.tasks)} zamanlanmÄ±ÅŸ gÃ¶rev yÃ¼klendi.")
            except Exception as e:
                print(f"GÃ¶revler yÃ¼klenirken hata: {e}")
                self.tasks = []
        else:
            print("GÃ¶rev dosyasÄ± bulunamadÄ±, yeni oluÅŸturulacak.")
            self.tasks = []
    
    def save_tasks(self):
        # GÃ¶revleri dosyaya kaydet
        try:
            with open(self.task_file, 'w') as f:
                json.dump(self.tasks, f)
            print(f"{len(self.tasks)} gÃ¶rev kaydedildi.")
        except Exception as e:
            print(f"GÃ¶revler kaydedilirken hata: {e}")
    
    def add_task(self, time, action, parameters=None, repeat="daily"):
        # Yeni gÃ¶rev ekle
        task = {
            "time": time,
            "action": action,
            "parameters": parameters or {},
            "repeat": repeat,
            "last_run": None
        }
        self.tasks.append(task)
        self.save_tasks()
        return len(self.tasks) - 1  # GÃ¶rev ID'sini dÃ¶ndÃ¼r
    
    def delete_task(self, task_id):
        # GÃ¶revi sil
        if 0 <= task_id < len(self.tasks):
            del self.tasks[task_id]
            self.save_tasks()
            return True
        return False
    
    def check_tasks(self):
        # Mevcut zamanÄ± al
        now = datetime.datetime.now()
        current_time = now.strftime("%H:%M")
        current_day = now.strftime("%A").lower()
        
        # TÃ¼m gÃ¶revleri kontrol et
        for task in self.tasks:
            # GÃ¶revin zamanÄ± geldi mi?
            if task["time"] == current_time:
                # Tekrar ayarÄ±na gÃ¶re kontrol
                if task["repeat"] == "daily" or \
                   (task["repeat"] == "weekdays" and current_day not in ["saturday", "sunday"]) or \
                   (task["repeat"] == "weekends" and current_day in ["saturday", "sunday"]) or \
                   (task["repeat"] == current_day):
                    
                    # Son Ã§alÄ±ÅŸtÄ±rma zamanÄ±nÄ± kontrol et
                    last_run = task.get("last_run")
                    if not last_run or not last_run.startswith(now.strftime("%Y-%m-%d")):
                        # GÃ¶revi Ã§alÄ±ÅŸtÄ±r
                        self.execute_task(task)
                        
                        # Son Ã§alÄ±ÅŸtÄ±rma zamanÄ±nÄ± gÃ¼ncelle
                        task["last_run"] = now.strftime("%Y-%m-%d %H:%M:%S")
                        self.save_tasks()
    
    def execute_task(self, task):
        # GÃ¶rev tipine gÃ¶re iÅŸlem yap
        action = task["action"]
        params = task["parameters"]
        
        print(f"GÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±lÄ±yor: {action}, parametreler: {params}")
        
        if action == "shutdown":
            # PC'yi kapat
            shutdown_time = params.get("delay", 60)  # VarsayÄ±lan 60 saniye
            
            # KullanÄ±cÄ±ya bildir
            QMessageBox.information(
                None, 
                "ZamanlanmÄ±ÅŸ GÃ¶rev", 
                f"BilgisayarÄ±nÄ±z {shutdown_time} saniye iÃ§inde kapatÄ±lacak.",
                QMessageBox.Ok
            )
            
            # Kapatma komutunu Ã§alÄ±ÅŸtÄ±r
            os.system(f"shutdown /s /t {shutdown_time}")
        
        elif action == "restart":
            # PC'yi yeniden baÅŸlat
            restart_time = params.get("delay", 60)  # VarsayÄ±lan 60 saniye
            
            # KullanÄ±cÄ±ya bildir
            QMessageBox.information(
                None, 
                "ZamanlanmÄ±ÅŸ GÃ¶rev", 
                f"BilgisayarÄ±nÄ±z {restart_time} saniye iÃ§inde yeniden baÅŸlatÄ±lacak.",
                QMessageBox.Ok
            )
            
            # Yeniden baÅŸlatma komutunu Ã§alÄ±ÅŸtÄ±r
            os.system(f"shutdown /r /t {restart_time}")
        
        elif action == "reminder":
            # HatÄ±rlatÄ±cÄ± gÃ¶ster
            QMessageBox.information(
                None, 
                "HatÄ±rlatÄ±cÄ±", 
                params.get("message", "ZamanlanmÄ±ÅŸ hatÄ±rlatÄ±cÄ±"),
                QMessageBox.Ok
            )
        
        elif action == "run_app":
            # Uygulama Ã§alÄ±ÅŸtÄ±r
            app_name = params.get("app_name", "")
            app_exe = params.get("app_exe", f"{app_name}.exe")
            if app_name and self.parent:
                # Mevcut uygulama aÃ§ma fonksiyonunu Ã§aÄŸÄ±r
                self.parent.find_and_run_app(app_name, app_exe)

    def add_immediate_task(self, delay_minutes, action, parameters=None):
        """Hemen/kÄ±sa sÃ¼reli gÃ¶rev ekler"""
        task = {
            "execute_time": time.time() + (delay_minutes * 60),  # Åu andan X dakika sonra
            "action": action,
            "parameters": parameters or {}
        }
        self.immediate_tasks.append(task)
        return len(self.immediate_tasks) - 1  # GÃ¶rev ID'sini dÃ¶ndÃ¼r

    def check_immediate_tasks(self):
        """AnlÄ±k gÃ¶revleri kontrol eder"""
        current_time = time.time()
        tasks_to_remove = []
        
        for i, task in enumerate(self.immediate_tasks):
            if current_time >= task["execute_time"]:
                # GÃ¶revi Ã§alÄ±ÅŸtÄ±r
                self.execute_task(task)
                tasks_to_remove.append(i)
        
        # Tamamlanan gÃ¶revleri listeden kaldÄ±r
        for i in reversed(tasks_to_remove):
            del self.immediate_tasks[i]

class App(QWidget):
    def __init__(self):
        super().__init__()
        
        # Discord RPC baÅŸlatma
        try:
            self.rpc = Presence("1350774636391956542")  # Discord uygulama ID'nizi buraya yazÄ±n
            self.rpc.connect()
            self.update_discord_status("Ana MenÃ¼", "TAI ile sohbet ediyor")
        except Exception as e:
            print(f"Discord RPC baÅŸlatÄ±lamadÄ±: {e}")
            self.rpc = None
        
        # API anahtarÄ±nÄ± sor
        self.get_api_key()
        
        # API anahtarÄ± yoksa uygulamayÄ± kapat
        if not GEMINI_API_KEY:
            sys.exit()
            
        # API anahtarÄ±nÄ± ayarla
        genai.configure(api_key=GEMINI_API_KEY)

        self.setWindowTitle('TAI - Yapay Zeka AsistanÄ±')
        self.setGeometry(100, 100, 1100, 800)
        
        # Ana uygulama stili
        self.setStyleSheet("""
            QWidget {
                background-color: #1e1e2e;
                font-family: 'Segoe UI', 'Arial';
                color: white;
            }
            QScrollBar:vertical {
                border: none;
                background: #2d2d3a;
                width: 8px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #6272a4;
                min-height: 20px;
                border-radius: 4px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
            QLineEdit {
                padding: 8px 12px;
                background-color: #383850;
                border: 1px solid #44445a;
                border-radius: 12px;
                color: white;
                font-size: 15px;
            }
            QLineEdit:focus {
                border: 1px solid #6272a4;
            }
            QPushButton {
                padding: 8px 16px;
                border-radius: 8px;
                font-weight: bold;
                color: white;
            }
            QPushButton:hover {
                opacity: 0.85;
            }
            QCheckBox {
                spacing: 8px;
                color: white;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border-radius: 4px;
            }
            QCheckBox::indicator:unchecked {
                border: 2px solid #6272a4;
                background-color: #2d2d3a;
            }
            QCheckBox::indicator:checked {
                border: 2px solid #6272a4;
                background-color: #6272a4;
            }
        """)
        
        # GÃ¶rsel analizi iÃ§in deÄŸiÅŸkenler
        self.current_image_path = None
        
        # Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ iÃ§in deÄŸiÅŸkenler
        self.screenshot_dir = "screenshots"
        self.is_auto_screenshot_enabled = False
        self.screenshot_timer = QTimer(self)
        self.screenshot_timer.timeout.connect(self.take_auto_screenshot)
        
        # UI gÃ¼ncellemeleri iÃ§in sinyal
        self.ui_signals = UISignals()
        self.ui_signals.update_ui.connect(self.on_update_ui)
        self.ui_signals.show_error.connect(self.on_show_error)
        
        # ZamanlanmÄ±ÅŸ gÃ¶revler yÃ¶neticisi
        self.task_manager = ScheduledTaskManager(self)
        
        # Screenshots klasÃ¶rÃ¼nÃ¼ oluÅŸtur
        if not os.path.exists(self.screenshot_dir):
            os.makedirs(self.screenshot_dir)

        self.initUI()
        
    def get_api_key(self):
        """KullanÄ±cÄ±dan API anahtarÄ± alÄ±r"""
        global GEMINI_API_KEY
        
        # Daha Ã¶nce kaydedilmiÅŸ API anahtarÄ±nÄ± kontrol et
        api_key_file = os.path.join(os.path.expanduser("~"), ".tai_api_key")
        
        if os.path.exists(api_key_file):
            try:
                with open(api_key_file, "r") as f:
                    saved_key = f.read().strip()
                    if saved_key:
                        # API anahtarÄ±nÄ± doÄŸrulamak iÃ§in bir onay mesajÄ± gÃ¶ster
                        response = QMessageBox.question(
                            None,
                            "KayÄ±tlÄ± API AnahtarÄ±",
                            "KayÄ±tlÄ± API anahtarÄ±nÄ±z bulundu. Bu anahtarÄ± kullanmak istiyor musunuz?",
                            QMessageBox.Yes | QMessageBox.No
                        )
                        
                        if response == QMessageBox.Yes:
                            GEMINI_API_KEY = saved_key
                            return
            except Exception as e:
                print(f"API anahtarÄ± okuma hatasÄ±: {e}")
        
        # API anahtarÄ± diyaloÄŸunu gÃ¶ster
        dialog = APIKeyDialog()
        result = dialog.exec_()
        
        if result == QDialog.Accepted and dialog.api_key:
            GEMINI_API_KEY = dialog.api_key
            
            # API anahtarÄ±nÄ± kaydetme seÃ§eneÄŸi sor
            save_response = QMessageBox.question(
                None,
                "API AnahtarÄ±nÄ± Kaydet",
                "API anahtarÄ±nÄ±zÄ± bilgisayarÄ±nÄ±za kaydetmek istiyor musunuz?\n"
                "Bu sayede uygulamayÄ± her aÃ§tÄ±ÄŸÄ±nÄ±zda tekrar girmenize gerek kalmaz.",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if save_response == QMessageBox.Yes:
                try:
                    with open(api_key_file, "w") as f:
                        f.write(GEMINI_API_KEY)
                    QMessageBox.information(None, "BaÅŸarÄ±lÄ±", "API anahtarÄ±nÄ±z kaydedildi.")
                except Exception as e:
                    QMessageBox.warning(None, "Hata", f"API anahtarÄ± kaydedilemedi: {str(e)}")

    def initUI(self):
        main_layout = QVBoxLayout()
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(0, 0, 0, 0)

        # BaÅŸlÄ±k kÄ±smÄ±
        title_frame = QFrame()
        title_frame.setObjectName("titleFrame")
        title_frame.setStyleSheet("""
            QFrame#titleFrame {
                background-color: #2d2d3a;
                border-bottom: 1px solid #44445a;
                min-height: 60px;
            }
        """)
        title_layout = QHBoxLayout(title_frame)
        title_layout.setContentsMargins(20, 10, 20, 10)
        
        # Logo/Ä°kon
        logo_label = QLabel()
        logo_label.setText("TAI")
        logo_label.setMaximumSize(40, 40)
        logo_label.setAlignment(Qt.AlignCenter)
        logo_label.setStyleSheet("background-color: #6272a4; border-radius: 20px; color: white; font-weight: bold; font-size: 16px;")
        title_layout.addWidget(logo_label)
        
        # BaÅŸlÄ±k
        title_label = QLabel("TAI - TÃ¼rkÃ§e Yapay Zeka AsistanÄ±")
        title_label.setStyleSheet("font-size: 20px; font-weight: bold; color: white; margin-left: 10px;")
        title_layout.addWidget(title_label)
        title_layout.addStretch()
        
        # API AnahtarÄ± deÄŸiÅŸtirme butonu
        api_button = QPushButton("API AnahtarÄ±nÄ± DeÄŸiÅŸtir")
        api_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #b3b3cc;
                border: none;
                font-size: 13px;
                font-weight: normal;
                text-decoration: underline;
                padding: 5px;
            }
            QPushButton:hover {
                color: white;
            }
        """)
        api_button.clicked.connect(self.change_api_key)
        title_layout.addWidget(api_button)
        
        main_layout.addWidget(title_frame)

        # Mesaj geÃ§miÅŸi alanÄ±
        message_container = QFrame()
        message_container.setObjectName("messageContainer")
        message_container.setStyleSheet("""
            QFrame#messageContainer {
                background-color: #282a36;
            }
        """)
        message_layout = QVBoxLayout(message_container)
        message_layout.setContentsMargins(0, 0, 0, 0)
        
        self.messages_area = QScrollArea()
        self.messages_area.setWidgetResizable(True)
        self.messages_area.setFrameStyle(QFrame.NoFrame)
        self.messages_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.messages_area.setStyleSheet("background-color: transparent;")
        
        self.messages_container = QWidget()
        self.messages_container.setStyleSheet("background-color: transparent;")
        self.messages_layout = QVBoxLayout(self.messages_container)
        self.messages_layout.setSpacing(15)  # Mesajlar arasÄ± boÅŸluk
        self.messages_layout.setContentsMargins(20, 20, 20, 20)
        self.messages_layout.addStretch()
        
        self.messages_area.setWidget(self.messages_container)
        message_layout.addWidget(self.messages_area)
        
        main_layout.addWidget(message_container, 1)  # Mesaj alanÄ± esnek olarak bÃ¼yÃ¼sÃ¼n

        # HoÅŸgeldin mesajÄ±
        welcome_message = ChatMessage("ğŸ‘‹ Merhaba! Ben TAI, TÃ¼rkÃ§e yapay zeka asistanÄ±nÄ±zÄ±m. Size nasÄ±l yardÄ±mcÄ± olabilirim?", is_user=False)
        self.messages_layout.addWidget(welcome_message)

        # Alt kÄ±sÄ±m - mesaj gÃ¶nderme alanÄ±
        bottom_frame = QFrame()
        bottom_frame.setObjectName("bottomFrame")
        bottom_frame.setStyleSheet("""
            QFrame#bottomFrame {
                background-color: #2d2d3a;
                border-top: 1px solid #44445a;
                min-height: 180px;
            }
        """)
        bottom_layout = QVBoxLayout(bottom_frame)
        bottom_layout.setContentsMargins(20, 15, 20, 15)
        
        # Butonlar iÃ§in layout
        control_layout = QHBoxLayout()
        control_layout.setSpacing(10)
        
        # Ä°konlu butonlar
        self.upload_button = QPushButton(" GÃ¶rsel YÃ¼kle")
        self.upload_button.setIcon(QIcon.fromTheme("document-open", QIcon()))
        self.upload_button.setIconSize(QSize(18, 18))
        self.upload_button.setStyleSheet("""
            QPushButton {
                background-color: #50fa7b;
                color: #282a36;
                font-weight: bold;
                padding: 10px 15px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: #5af78e;
            }
        """)
        self.upload_button.clicked.connect(self.open_file)
        
        self.analyze_button = QPushButton(" GÃ¶rseli Analiz Et")
        self.analyze_button.setIcon(QIcon.fromTheme("view-preview", QIcon()))
        self.analyze_button.setIconSize(QSize(18, 18))
        self.analyze_button.setStyleSheet("""
            QPushButton {
                background-color: #f1fa8c;
                color: #282a36;
                font-weight: bold;
                padding: 10px 15px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: #f4f99d;
            }
            QPushButton:disabled {
                background-color: #6272a4;
                color: #b3b3cc;
            }
        """)
        self.analyze_button.clicked.connect(self.analyze_image_with_ai)
        self.analyze_button.setEnabled(False)  # BaÅŸlangÄ±Ã§ta devre dÄ±ÅŸÄ±
        
        self.screenshot_button = QPushButton(" Ekran GÃ¶rÃ¼ntÃ¼sÃ¼ Al")
        self.screenshot_button.setIcon(QIcon.fromTheme("camera-photo", QIcon()))
        self.screenshot_button.setIconSize(QSize(18, 18))
        self.screenshot_button.setStyleSheet("""
            QPushButton {
                background-color: #bd93f9;
                color: white;
                font-weight: bold;
                padding: 10px 15px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: #caa9fa;
            }
        """)
        self.screenshot_button.clicked.connect(self.take_screenshot)
        
        self.auto_screenshot_checkbox = QCheckBox("Dakikada Bir Ekran Analizi")
        self.auto_screenshot_checkbox.setStyleSheet("""
            QCheckBox {
                color: white;
                font-size: 14px;
                padding: 10px;
            }
        """)
        self.auto_screenshot_checkbox.stateChanged.connect(self.toggle_auto_screenshot)
        
        self.web_search_button = QPushButton(" Web'de Ara")
        self.web_search_button.setIcon(QIcon.fromTheme("edit-find", QIcon()))
        self.web_search_button.setIconSize(QSize(18, 18))
        self.web_search_button.setStyleSheet("""
            QPushButton {
                background-color: #ff79c6;
                color: white;
                font-weight: bold;
                padding: 10px 15px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: #ff92d0;
            }
        """)
        self.web_search_button.clicked.connect(self.show_web_search_dialog)
        
        control_layout.addWidget(self.upload_button)
        control_layout.addWidget(self.analyze_button)
        control_layout.addWidget(self.screenshot_button)
        control_layout.addWidget(self.auto_screenshot_checkbox)
        control_layout.addWidget(self.web_search_button)
        bottom_layout.addLayout(control_layout)
        
        # Mesaj giriÅŸ alanÄ±
        input_layout = QHBoxLayout()
        input_layout.setContentsMargins(0, 10, 0, 0)
        input_layout.setSpacing(10)
        
        self.chat_input = QLineEdit()
        self.chat_input.setPlaceholderText("Bir mesaj yazÄ±n veya 'Chrome'u aÃ§' gibi bir komut verin...")
        self.chat_input.setMinimumHeight(50)
        self.chat_input.setStyleSheet("""
            QLineEdit {
                background-color: #383850;
                border: 1px solid #44445a;
                border-radius: 25px;
                color: white;
                font-size: 15px;
                padding: 0 20px;
            }
            QLineEdit:focus {
                border: 1px solid #6272a4;
            }
        """)
        self.chat_input.returnPressed.connect(self.send_message)
        
        send_button = QPushButton()
        send_button.setIcon(QIcon.fromTheme("arrow-right", QIcon()))
        send_button.setIconSize(QSize(20, 20))
        send_button.setFixedSize(50, 50)
        send_button.setStyleSheet("""
            QPushButton {
                background-color: #ff79c6;
                border-radius: 25px;
                padding: 5px;
            }
            QPushButton:hover {
                background-color: #ff92d0;
            }
        """)
        send_button.clicked.connect(self.send_message)
        
        input_layout.addWidget(self.chat_input)
        input_layout.addWidget(send_button)
        bottom_layout.addLayout(input_layout)
        
        main_layout.addWidget(bottom_frame)
        
        self.setLayout(main_layout)
        
        # GÃ¶rsel Ã¶nizleme alanÄ± (baÅŸlangÄ±Ã§ta gizli)
        self.image_preview = QLabel()
        self.image_preview.setAlignment(Qt.AlignCenter)
        self.image_preview.setStyleSheet("""
            background-color: #383850;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
        """)
        self.image_preview.hide()
        self.messages_layout.addWidget(self.image_preview)
    
    def change_api_key(self):
        """API anahtarÄ±nÄ± deÄŸiÅŸtirme fonksiyonu"""
        global GEMINI_API_KEY
        
        dialog = APIKeyDialog()
        result = dialog.exec_()
        
        if result == QDialog.Accepted and dialog.api_key:
            old_key = GEMINI_API_KEY
            GEMINI_API_KEY = dialog.api_key
            
            # API anahtarÄ±nÄ± kaydetme seÃ§eneÄŸi sor
            save_response = QMessageBox.question(
                self,
                "API AnahtarÄ±nÄ± Kaydet",
                "Yeni API anahtarÄ±nÄ±zÄ± bilgisayarÄ±nÄ±za kaydetmek istiyor musunuz?",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if save_response == QMessageBox.Yes:
                api_key_file = os.path.join(os.path.expanduser("~"), ".tai_api_key")
                try:
                    with open(api_key_file, "w") as f:
                        f.write(GEMINI_API_KEY)
                    QMessageBox.information(self, "BaÅŸarÄ±lÄ±", "Yeni API anahtarÄ±nÄ±z kaydedildi.")
                except Exception as e:
                    QMessageBox.warning(self, "Hata", f"API anahtarÄ± kaydedilemedi: {str(e)}")
            
            # Genai yapÄ±landÄ±rmasÄ±nÄ± gÃ¼ncelle
            genai.configure(api_key=GEMINI_API_KEY)
            
            # KullanÄ±cÄ±ya baÅŸarÄ±lÄ± mesajÄ± gÃ¶ster
            success_message = ChatMessage("API anahtarÄ±nÄ±z baÅŸarÄ±yla deÄŸiÅŸtirildi.", is_user=False)
            self.messages_layout.addWidget(success_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )

    def button_style(self, color):
        # ArtÄ±k kullanÄ±lmÄ±yor - her buton kendi stilini alÄ±yor
        return f"""
            QPushButton {{
                background-color: {color};
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                font-weight: bold;
                font-size: 14px;
            }}
            QPushButton:hover {{
                background-color: {color}cc;
            }}
        """

    def send_message(self):
        user_text = self.chat_input.text().strip()
        if not user_text:
            return
            
        # Discord durumunu gÃ¼ncelle
        self.update_discord_status("Sohbet", "TAI ile mesajlaÅŸÄ±yor")
            
        # KullanÄ±cÄ± mesajÄ±nÄ± ekle
        user_message = ChatMessage(user_text, is_user=True)
        self.messages_layout.addWidget(user_message)
        
        # GiriÅŸ alanÄ±nÄ± temizle
        self.chat_input.clear()
        
        # Ã–nce program aÃ§ma komutunu kontrol et
        if self.check_and_run_app_command(user_text):
            # Program aÃ§ma komutu baÅŸarÄ±yla iÅŸlendiyse, AI yanÄ±tÄ± istenmiyor
            pass
        # Dosya iÅŸlemleri komutunu kontrol et
        elif self.check_and_run_file_command(user_text):
            # Dosya iÅŸlemi komutu baÅŸarÄ±yla iÅŸlendiyse, AI yanÄ±tÄ± istenmiyor
            pass
        # ZamanlanmÄ±ÅŸ gÃ¶rev komutlarÄ±nÄ± kontrol et
        elif self.check_and_run_scheduled_task_command(user_text):
            # ZamanlanmÄ±ÅŸ gÃ¶rev komutu baÅŸarÄ±yla iÅŸlendiyse, AI yanÄ±tÄ± istenmiyor
            pass
        else:
            # HiÃ§bir Ã¶zel komut deÄŸilse, normal AI yanÄ±tÄ±nÄ± al
            self.get_ai_response(user_text)
        
        # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
        QApplication.processEvents()
        self.messages_area.verticalScrollBar().setValue(
            self.messages_area.verticalScrollBar().maximum()
        )

    def check_and_run_app_command(self, text):
        """KullanÄ±cÄ± mesajÄ±nÄ± analiz eder ve program aÃ§ma komutu varsa uygulamayÄ± aÃ§ar"""
        # Program aÃ§ma komutlarÄ±nÄ± tespit etmek iÃ§in dÃ¼zenli ifadeler
        app_patterns = [
            r'(.*?)(?:\'u|\'Ä±|\'i|\'yi|\'yÄ±|yi|yÄ±|i|Ä±|u|Ã¼)\s+aÃ§(?:ar\s+mÄ±sÄ±n)?',  # X'i aÃ§, X'Ä± aÃ§, X'u aÃ§, X'Ã¼ aÃ§, Xi aÃ§, XÄ± aÃ§, Xu aÃ§, XÃ¼ aÃ§
            r'(.*?)\s+programÄ±nÄ±\s+aÃ§(?:ar\s+mÄ±sÄ±n)?',  # X programÄ±nÄ± aÃ§
            r'(.*?)\s+Ã§alÄ±ÅŸtÄ±r(?:Ä±r\s+mÄ±sÄ±n)?'  # X Ã§alÄ±ÅŸtÄ±r
        ]
        
        for pattern in app_patterns:
            match = re.search(pattern, text.lower())
            if match:
                app_name = match.group(1).strip()
                # YaygÄ±n program adÄ± dÃ¼zeltmeleri
                app_map = {
                    'chrome': 'chrome.exe',
                    'krom': 'chrome.exe',
                    'google chrome': 'chrome.exe',
                    'edge': 'msedge.exe',
                    'microsoft edge': 'msedge.exe',
                    'firefox': 'firefox.exe',
                    'mozilla firefox': 'firefox.exe',
                    'explorer': 'explorer.exe',
                    'dosya gezgini': 'explorer.exe',
                    'word': 'winword.exe',
                    'excel': 'excel.exe',
                    'powerpoint': 'powerpnt.exe',
                    'notepad': 'notepad.exe',
                    'not defteri': 'notepad.exe',
                    'hesap makinesi': 'calc.exe',
                    'hesap makinasÄ±': 'calc.exe',
                    'calculator': 'calc.exe',
                    'paint': 'mspaint.exe',
                    'spotify': 'spotify.exe',
                    'discord': 'discord.exe',
                    'telegram': 'telegram.exe',
                    'whatsapp': 'whatsapp.exe',
                    'vs code': 'code.exe',
                    'visual studio code': 'code.exe',
                    'visual studio': 'devenv.exe',
                }
                
                # EÅŸleÅŸen program adÄ± varsa dÃ¼zelt
                if app_name in app_map:
                    app_exe = app_map[app_name]
                else:
                    # Yoksa .exe ekle
                    app_exe = f"{app_name}.exe"
                
                # ProgramÄ± bul ve Ã§alÄ±ÅŸtÄ±r
                if self.find_and_run_app(app_name, app_exe):
                    return True  # Program aÃ§ma komutu iÅŸlendi
        
        return False  # Program aÃ§ma komutu deÄŸil
    
    def find_and_run_app(self, app_name, app_exe):
        """ProgramÄ± sistemde arar ve bulursa Ã§alÄ±ÅŸtÄ±rÄ±r"""
        try:
            # Program bilgisi mesajÄ±
            info_message = ChatMessage(f"'{app_name}' programÄ±nÄ± arÄ±yorum...", is_user=False)
            self.messages_layout.addWidget(info_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            
            # YaygÄ±n program yollarÄ±
            common_paths = [
                r"C:\Program Files",
                r"C:\Program Files (x86)",
                os.path.join(os.environ['LOCALAPPDATA'], "Programs"),
                os.environ['APPDATA'],
                os.path.join(os.environ['LOCALAPPDATA']),
                os.path.join(os.environ['USERPROFILE'], "AppData", "Local"),
                os.path.join(os.environ['USERPROFILE'], "AppData", "Roaming"),
                os.path.join(os.environ['USERPROFILE'], "AppData", "Local", "Programs"),
                r"C:\Windows",
                r"C:\Windows\System32"
            ]
            
            # Program exe'sini ara
            app_path = None
            for path in common_paths:
                if not os.path.exists(path):
                    continue
                    
                # Ä°lk arama yÃ¶ntemi: direkt exe arama
                for root, dirs, files in os.walk(path):
                    if app_exe.lower() in [f.lower() for f in files]:
                        for file in files:
                            if file.lower() == app_exe.lower():
                                app_path = os.path.join(root, file)
                                # Bulundu, aramayÄ± durdur
                                break
                    # Bulunduysa ana dÃ¶ngÃ¼yÃ¼ kÄ±r
                    if app_path:
                        break
                        
                # Bulunduysa sonraki dizinlere bakma
                if app_path:
                    break
            
            # Program bulunamadÄ±ysa PATH'de ara
            if not app_path:
                try:
                    # Sistemde programÄ±n yolunu bulmak iÃ§in where komutunu kullan
                    result = subprocess.run(['where', app_exe], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                    if result.returncode == 0 and result.stdout.strip():
                        app_path = result.stdout.strip().split('\n')[0]
                except Exception as e:
                    print(f"PATH'de arama hatasÄ±: {e}")
            
            # Program bulunduysa Ã§alÄ±ÅŸtÄ±r
            if app_path:
                # ProgramÄ± baÅŸlat
                subprocess.Popen(app_path)
                
                # BaÅŸarÄ± mesajÄ±
                success_message = ChatMessage(f"âœ… '{app_name}' programÄ± baÅŸarÄ±yla aÃ§Ä±ldÄ±.", is_user=False)
                self.messages_layout.addWidget(success_message)
                return True
            else:
                # BulunamadÄ± mesajÄ±
                not_found = ChatMessage(f"âŒ '{app_name}' programÄ± bulunamadÄ±. LÃ¼tfen farklÄ± bir program adÄ± deneyin.", is_user=False)
                self.messages_layout.addWidget(not_found)
                return True  # Yine de komutu iÅŸlenmiÅŸ olarak kabul et
                
        except Exception as e:
            # Hata mesajÄ±
            error_message = ChatMessage(f"ProgramÄ± aÃ§arken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
            return True  # Komutu iÅŸlenmiÅŸ olarak kabul et
        
    def get_ai_response(self, user_input):
        try:
            # Ä°ÅŸleniyor mesajÄ±
            processing_msg = ChatMessage("âŒ› YanÄ±t hazÄ±rlanÄ±yor...", is_user=False)
            self.messages_layout.addWidget(processing_msg)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
            
            # AI yanÄ±tÄ±nÄ± al
            response = genai.GenerativeModel("gemini-1.5-flash").generate_content([user_input])
            ai_text = response.text.strip()
            
            # Ä°ÅŸleniyor mesajÄ±nÄ± kaldÄ±r
            self.messages_layout.removeWidget(processing_msg)
            processing_msg.deleteLater()
            
            # AI mesajÄ±nÄ± ekle
            ai_message = ChatMessage(ai_text, is_user=False)
            self.messages_layout.addWidget(ai_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
        except Exception as e:
            # Ä°ÅŸleniyor mesajÄ±nÄ± kaldÄ±r
            self.messages_layout.removeWidget(processing_msg)
            processing_msg.deleteLater()
            
            # Hata mesajÄ±nÄ± ekle
            error_message = ChatMessage(f"âŒ Bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)

    def open_file(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getOpenFileName(self, "Bir GÃ¶rsel SeÃ§in", "", "Images (*.png *.jpg *.jpeg *.bmp)", options=options)

        if file_path:
            self.preview_image(file_path)
            self.current_image_path = file_path
            self.analyze_button.setEnabled(True)  # GÃ¶rsel yÃ¼klendiÄŸinde analiz butonunu aktif et

    def preview_image(self, image_path):
        try:
            image = Image.open(image_path)
            image.thumbnail((400, 300))  # Boyutu sÄ±nÄ±rla
            
            # GÃ¶rseli PyQt5 uyumlu hale getir
            qimage = QImage(image_path)
            pixmap = QPixmap.fromImage(qimage).scaled(400, 300, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            
            # Yuvarlak kÃ¶ÅŸeli Ã§erÃ§evede gÃ¶rÃ¼ntÃ¼le
            self.image_preview.setPixmap(pixmap)
            self.image_preview.show()
            
            # Resim yÃ¼klendi mesajÄ±
            message = ChatMessage(f"ğŸ“¸ GÃ¶rsel yÃ¼klendi: {os.path.basename(image_path)}", is_user=True)
            self.messages_layout.addWidget(message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
        except Exception as e:
            error_message = ChatMessage(f"GÃ¶rsel yÃ¼klenirken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)

    def analyze_image_with_ai(self):
        if not self.current_image_path:
            message = ChatMessage("â— LÃ¼tfen Ã¶nce bir gÃ¶rsel yÃ¼kleyin!", is_user=False)
            self.messages_layout.addWidget(message)
            return
            
        try:
            # Discord durumunu gÃ¼ncelle
            self.update_discord_status("GÃ¶rsel Analizi", "Yapay zeka ile gÃ¶rsel analiz ediyor")
            
            # Analiz iÅŸlemi baÅŸladÄ± mesajÄ±
            self.process_message = ChatMessage("ğŸ” GÃ¶rsel analiz ediliyor...", is_user=False)
            self.messages_layout.addWidget(self.process_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
            
            # GÃ¶rsel analizi iÃ§in Gemini'ye istek gÃ¶nder
            def analyze_thread():
                try:
                    image = Image.open(self.current_image_path)
                    model = genai.GenerativeModel('gemini-2.0-flash')
                    response = model.generate_content(["Bu gÃ¶rseli analiz et ve aÃ§Ä±kla.", image])
                    analysis_text = response.text
                    
                    # Sinyali kullanarak UI'Ä± gÃ¼ncelle
                    self.ui_signals.update_ui.emit({"type": "image_analysis", "text": analysis_text})
                    
                except Exception as e:
                    # Hata durumunda sinyali kullanarak hata mesajÄ± gÃ¶ster
                    self.ui_signals.show_error.emit(f"âŒ GÃ¶rsel analiz edilirken bir hata oluÅŸtu: {str(e)}", self.process_message)
            
            # Analiz iÅŸlemini ayrÄ± bir thread'de baÅŸlat
            threading.Thread(target=analyze_thread, daemon=True).start()
            
        except Exception as e:
            error_message = ChatMessage(f"âŒ GÃ¶rsel analiz edilirken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
    
    def take_screenshot(self):
        """Manuel olarak ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma ve analiz etme"""
        try:
            # Discord durumunu gÃ¼ncelle
            self.update_discord_status("Ekran Analizi", "Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ analiz ediyor")
            
            # Bilgi mesajÄ±
            self.info_message = ChatMessage("ğŸ“· Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±nÄ±yor...", is_user=False)
            self.messages_layout.addWidget(self.info_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
            
            # Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma ve kaydetme iÅŸlemi
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_path = os.path.join(self.screenshot_dir, f"screenshot_{timestamp}.png")
            
            # Uygulama kÄ±sa sÃ¼reliÄŸine minimize edilir (opsiyonel)
            self.showMinimized()
            time.sleep(0.5)  # EkranÄ±n minimize olmasÄ± iÃ§in kÄ±sa bir bekleme
            
            # Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma
            screenshot = pyautogui.screenshot()
            screenshot.save(screenshot_path)
            
            # UygulamayÄ± tekrar gÃ¶ster
            self.showNormal()
            
            # Analiz etmek iÃ§in gÃ¶rÃ¼ntÃ¼yÃ¼ yÃ¼kle ve analiz et
            self.current_image_path = screenshot_path
            self.analyze_screenshot(screenshot_path, self.info_message)
            
        except Exception as e:
            error_message = ChatMessage(f"âŒ Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±nÄ±rken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
    
    def take_auto_screenshot(self):
        """Otomatik olarak ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma ve analiz etme"""
        try:
            # Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma ve kaydetme iÅŸlemi
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_path = os.path.join(self.screenshot_dir, f"auto_screenshot_{timestamp}.png")
            
            # Uygulama minimize edilir (opsiyonel)
            self.showMinimized()
            time.sleep(0.5)  # EkranÄ±n minimize olmasÄ± iÃ§in kÄ±sa bir bekleme
            
            # Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma
            screenshot = pyautogui.screenshot()
            screenshot.save(screenshot_path)
            
            # UygulamayÄ± tekrar gÃ¶ster
            self.showNormal()
            
            # Bilgi mesajÄ±
            self.info_message = ChatMessage(f"Otomatik ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±ndÄ±: {timestamp}", is_user=False)
            self.messages_layout.addWidget(self.info_message)
            
            # Analiz et
            self.current_image_path = screenshot_path
            self.analyze_screenshot(screenshot_path, self.info_message, is_auto=True)
            
        except Exception as e:
            error_message = ChatMessage(f"âŒ Otomatik ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alÄ±nÄ±rken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
    
    def analyze_screenshot(self, screenshot_path, info_message=None, is_auto=False):
        """Ekran gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ analiz eden fonksiyon"""
        try:
            def analyze_thread():
                try:
                    image = Image.open(screenshot_path)
                    model = genai.GenerativeModel('gemini-2.0-flash')
                    
                    if is_auto:
                        prompt = [
                            "Bu bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼dÃ¼r. LÃ¼tfen ÅŸunlarÄ± yap:"
                            "1. Ekranda ne olduÄŸunu kÄ±saca aÃ§Ä±kla"
                            "2. KullanÄ±cÄ±nÄ±n ne yaptÄ±ÄŸÄ±nÄ± tahmin et"
                            "3. KullanÄ±cÄ±ya faydalÄ± ipuÃ§larÄ± ve Ã¶neriler ver"
                            "4. KullanÄ±cÄ±nÄ±n daha verimli Ã§alÄ±ÅŸmasÄ± iÃ§in tavsiyelerde bulun"
                            "YanÄ±tÄ±nÄ± TÃ¼rkÃ§e olarak, madde madde ve rehber formatÄ±nda hazÄ±rla.",
                            image
                        ]
                    else:
                        prompt = ["Bu ekran gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ detaylÄ± olarak analiz et ve eÄŸer gÃ¶rÃ¼ntÃ¼de kod varsa kodda hata vs. varsa uyar", image]
                    
                    response = model.generate_content(prompt)
                    analysis_text = response.text
                    
                    # Sinyali kullanarak UI'Ä± gÃ¼ncelle
                    data = {
                        "type": "screenshot_analysis", 
                        "text": analysis_text, 
                        "is_auto": is_auto,
                        "info_message": info_message
                    }
                    self.ui_signals.update_ui.emit(data)
                    
                except Exception as e:
                    # Hata durumunda sinyali kullanarak hata mesajÄ± gÃ¶ster
                    self.ui_signals.show_error.emit(f"âŒ Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ analiz edilirken bir hata oluÅŸtu: {str(e)}", info_message)
            
            # Analiz iÅŸlemini ayrÄ± bir thread'de baÅŸlat
            threading.Thread(target=analyze_thread, daemon=True).start()
            
        except Exception as e:
            error_message = ChatMessage(f"âŒ Ekran gÃ¶rÃ¼ntÃ¼sÃ¼ analiz iÅŸlemi baÅŸlatÄ±lÄ±rken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
    
    def on_update_ui(self, data):
        """UI gÃ¼ncellemelerini yapan metot (Sinyal tarafÄ±ndan Ã§aÄŸrÄ±lÄ±r)"""
        try:
            if data["type"] == "image_analysis":
                result_message = ChatMessage(data["text"], is_user=False)
                self.messages_layout.addWidget(result_message)
                
                # Process mesajÄ±nÄ± kaldÄ±r
                self.messages_layout.removeWidget(self.process_message)
                self.process_message.deleteLater()
                
            elif data["type"] == "screenshot_analysis":
                info_message = data["info_message"]
                if info_message:
                    # Mevcut bilgi mesajÄ±nÄ± kaldÄ±r
                    self.messages_layout.removeWidget(info_message)
                    info_message.deleteLater()
                
                if data["is_auto"]:
                    title = f"ğŸ–¥ï¸ EKRAN ANALÄ°Z RAPORU ({datetime.datetime.now().strftime('%H:%M')})"
                    result_message = ChatMessage(f"{title}\n\n{data['text']}", is_user=False)
                else:
                    result_message = ChatMessage(data["text"], is_user=False)
                    
                self.messages_layout.addWidget(result_message)
            
            elif data["type"] == "web_search":
                # Web arama iÅŸleme
                processing_msg = data["processing_msg"]
                query = data["query"]
                results = data["results"]
                
                # Ä°ÅŸleme mesajÄ±nÄ± kaldÄ±r
                self.messages_layout.removeWidget(processing_msg)
                processing_msg.deleteLater()
                
                if results:
                    # SonuÃ§larÄ± hazÄ±rla
                    result_text = f"ğŸ“Š '{query}' iÃ§in arama sonuÃ§larÄ±:\n\n"
                    
                    for idx, result in enumerate(results, 1):
                        result_text += f"{idx}. {result['title']}\n"
                        result_text += f"   {result['link']}\n"
                        result_text += f"   {result['description']}\n\n"
                    
                    # Veya sonuÃ§ yok
                    if not results:
                        result_text += "Arama sonucu bulunamadÄ±."
                    
                    # SonuÃ§ mesajÄ±nÄ± ekle
                    result_message = ChatMessage(result_text, is_user=False)
                    self.messages_layout.addWidget(result_message)
                else:
                    # SonuÃ§ bulunamazsa
                    no_result = ChatMessage("Bu arama iÃ§in sonuÃ§ bulunamadÄ±. LÃ¼tfen farklÄ± anahtar kelimelerle tekrar deneyin.", is_user=False)
                    self.messages_layout.addWidget(no_result)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
        except Exception as e:
            print(f"UI gÃ¼ncelleme hatasÄ±: {e}")
    
    def on_show_error(self, error_text, info_message=None):
        """Hata mesajlarÄ±nÄ± gÃ¶steren metot (Sinyal tarafÄ±ndan Ã§aÄŸrÄ±lÄ±r)"""
        try:
            error_message = ChatMessage(error_text, is_user=False)
            self.messages_layout.addWidget(error_message)
            
            if info_message:
                # Bilgi mesajÄ±nÄ± kaldÄ±r
                self.messages_layout.removeWidget(info_message)
                info_message.deleteLater()
                
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            self.messages_area.verticalScrollBar().setValue(
                self.messages_area.verticalScrollBar().maximum()
            )
        except Exception as e:
            print(f"Hata gÃ¶sterme hatasÄ±: {e}")
    
    def toggle_auto_screenshot(self, state):
        """Otomatik ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma Ã¶zelliÄŸini aÃ§Ä±p kapatÄ±r"""
        if state == Qt.Checked:
            # Otomatik ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma Ã¶zelliÄŸini aktifleÅŸtir
            self.is_auto_screenshot_enabled = True
            self.screenshot_timer.start(60000)  # 60000 ms = 1 dakika
            
            # Bilgi mesajÄ±
            info_message = ChatMessage("Otomatik ekran analizi baÅŸlatÄ±ldÄ±. Dakikada bir analiz yapÄ±lacak.", is_user=False)
            self.messages_layout.addWidget(info_message)
            
            # Ä°lk ekran gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ hemen al
            QTimer.singleShot(1000, self.take_auto_screenshot)
            
        else:
            # Otomatik ekran gÃ¶rÃ¼ntÃ¼sÃ¼ alma Ã¶zelliÄŸini devre dÄ±ÅŸÄ± bÄ±rak
            self.is_auto_screenshot_enabled = False
            self.screenshot_timer.stop()
            
            # Bilgi mesajÄ±
            info_message = ChatMessage("Otomatik ekran analizi durduruldu.", is_user=False)
            self.messages_layout.addWidget(info_message)

    def show_web_search_dialog(self):
        """Web arama dialogunu gÃ¶sterir"""
        search_dialog = QDialog(self)
        search_dialog.setWindowTitle("Web'de Ara")
        search_dialog.setMinimumWidth(450)
        search_dialog.setStyleSheet("""
            QDialog {
                background-color: #282a36;
                color: white;
                border-radius: 10px;
            }
            QLabel {
                color: white;
                font-size: 15px;
                font-weight: bold;
                margin-bottom: 5px;
            }
            QLineEdit {
                background-color: #383850;
                color: white;
                border: 1px solid #44445a;
                border-radius: 8px;
                padding: 12px;
                font-size: 14px;
            }
            QLineEdit:focus {
                border: 1px solid #6272a4;
            }
            QPushButton {
                background-color: #ff79c6;
                color: white;
                font-weight: bold;
                border-radius: 8px;
                padding: 12px;
                font-size: 15px;
            }
            QPushButton:hover {
                background-color: #ff92d0;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # BaÅŸlÄ±k
        title_label = QLabel("Web'de Ne Aramak Ä°stersiniz?")
        title_label.setAlignment(Qt.AlignCenter)
        title_label.setStyleSheet("font-size: 18px; margin-bottom: 15px;")
        
        # Arama giriÅŸi
        search_label = QLabel("Arama Sorgusu:")
        search_input = QLineEdit()
        search_input.setPlaceholderText("Web'de aramak istediÄŸiniz bilgiyi girin")
        
        # Arama butonu
        search_button = QPushButton("Ara")
        search_button.setIcon(QIcon.fromTheme("edit-find", QIcon()))
        
        # Layout dÃ¼zenleme
        layout.addWidget(title_label)
        layout.addWidget(search_label)
        layout.addWidget(search_input)
        layout.addWidget(search_button)
        
        search_dialog.setLayout(layout)
        
        # Arama butonuna fonksiyon baÄŸlama
        search_button.clicked.connect(lambda: self.perform_web_search(search_input.text(), search_dialog))
        
        # Enter tuÅŸuna fonksiyon baÄŸlama
        search_input.returnPressed.connect(lambda: self.perform_web_search(search_input.text(), search_dialog))
        
        search_dialog.exec_()

    def perform_web_search(self, query, dialog=None):
        """Web aramasÄ± yapar ve sonuÃ§larÄ± gÃ¶sterir"""
        if not query:
            return
        
        # Dialog'u kapat
        if dialog:
            dialog.accept()
        
        # Arama iÅŸlemi baÅŸladÄ± bilgisi
        search_msg = ChatMessage(f"Web'de arÄ±yorum: '{query}'", is_user=True)
        self.messages_layout.addWidget(search_msg)
        
        processing_msg = ChatMessage("Arama sonuÃ§larÄ± alÄ±nÄ±yor...", is_user=False)
        self.messages_layout.addWidget(processing_msg)
        
        # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
        QApplication.processEvents()
        self.messages_area.verticalScrollBar().setValue(
            self.messages_area.verticalScrollBar().maximum()
        )
        
        # Thread'de web aramasÄ± yap
        def search_thread():
            try:
                results = self.search_web(query)
                
                # SonuÃ§larÄ± ana thread'de gÃ¶ster
                self.ui_signals.update_ui.emit({
                    "type": "web_search", 
                    "results": results,
                    "query": query,
                    "processing_msg": processing_msg
                })
            except Exception as e:
                self.ui_signals.show_error.emit(f"âŒ Web aramasÄ± sÄ±rasÄ±nda bir hata oluÅŸtu: {str(e)}", processing_msg)
        
        # Arama thread'ini baÅŸlat
        threading.Thread(target=search_thread, daemon=True).start()

    def search_web(self, query):
        """Web aramasÄ± yapÄ±p sonuÃ§larÄ± dÃ¶ndÃ¼rÃ¼r"""
        try:
            print(f"Arama sorgusu: {query}")
            user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36'
            headers = {'User-Agent': user_agent}
            
            results = []
            
            # 1. Google/Gemini aramasÄ± (birincil)
            print("Google/Gemini ile arama yapÄ±lÄ±yor...")
            try:
                # Gemini modelini kullan
                model = genai.GenerativeModel('gemini-1.5-flash')
                prompt = f"""'{query}' iÃ§in web'de arama yapÄ±yorum. 
                LÃ¼tfen bu konuda kÄ±sa bilgi ver ve 5 tane web sitesi Ã¶ner.
                Her site iÃ§in baÅŸlÄ±k, URL ve kÄ±sa aÃ§Ä±klamasÄ± olmalÄ±. 
                YanÄ±tÄ±nÄ± TÃœRKÃ‡E olarak ver ve bilgileri aÅŸaÄŸÄ±daki formatta dÃ¼zenle:
                
                1. [BaÅŸlÄ±k 1]
                   [URL 1]
                   [AÃ§Ä±klama 1]
                
                2. [BaÅŸlÄ±k 2]
                   [URL 2]
                   [AÃ§Ä±klama 2]
                
                (vs. diÄŸer sonuÃ§lar)
                """
                
                response = model.generate_content(prompt)
                if response and response.text:
                    # Gemini yanÄ±tÄ±nÄ± iÅŸle ve uygun formata Ã§evir
                    ai_text = response.text
                    
                    # Gemini yanÄ±tÄ±nÄ± satÄ±rlara bÃ¶l
                    lines = ai_text.split('\n')
                    
                    current_result = {}
                    counter = 0
                    
                    for line in lines:
                        line = line.strip()
                        if not line:
                            continue
                            
                        # Yeni bir sonuÃ§ baÅŸlangÄ±cÄ± mÄ±?
                        if line.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.')):
                            # Ã–nceki sonucu kaydet (eÄŸer varsa)
                            if current_result and 'title' in current_result and 'link' in current_result and 'description' in current_result:
                                results.append(current_result)
                                print(f"Google/Gemini sonucu eklendi: {current_result['title']}")
                            
                            # Yeni sonuÃ§ baÅŸlat
                            current_result = {}
                            # BaÅŸlÄ±ÄŸÄ± ayÄ±kla (numara kÄ±smÄ±nÄ± kaldÄ±r: "1. BaÅŸlÄ±k" -> "BaÅŸlÄ±k")
                            title_parts = line.split('. ', 1)
                            if len(title_parts) > 1:
                                current_result['title'] = title_parts[1].strip()
                            counter = 1  # Sonraki satÄ±r URL olacak
                            
                        elif counter == 1 and 'title' in current_result:
                            # URL satÄ±rÄ±
                            if line.startswith('http'):
                                current_result['link'] = line
                            else:
                                # URL deÄŸilse, baÅŸlÄ±ÄŸÄ±n devamÄ± olabilir
                                current_result['title'] += ' ' + line
                                counter = 0  # URL gelmedi, hala baÅŸlÄ±k iÃ§indeyiz
                            counter = 2  # Sonraki satÄ±r aÃ§Ä±klama olacak
                            
                        elif counter == 2 and 'link' in current_result:
                            # AÃ§Ä±klama satÄ±rÄ±
                            current_result['description'] = line
                            counter = 0
                    
                    # Son sonucu da ekle
                    if current_result and 'title' in current_result and 'link' in current_result and 'description' in current_result:
                        results.append(current_result)
                        print(f"Google/Gemini sonucu eklendi: {current_result['title']}")
                    
                    # EÄŸer hiÃ§ dÃ¼zgÃ¼n sonuÃ§ Ã§Ä±karamadÄ±ysak, tam metni tek bir sonuÃ§ olarak ekle
                    if not results:
                        results.append({
                            'title': "Google Arama SonuÃ§larÄ±",
                            'link': "https://www.google.com/search?q=" + query.replace(' ', '+') + "&hl=tr",
                            'description': ai_text[:200] + "..."  # Ä°lk 200 karakteri al
                        })
            except Exception as e:
                print(f"Google/Gemini arama hatasÄ±: {e}")
            
            # Google'da sonuÃ§ bulunamazsa Bing ile dene
            if not results:
                print("Google/Gemini'de sonuÃ§ bulunamadÄ±, Bing deneniyor...")
                
                # 2. Bing aramasÄ± (ikincil)
                bing_url = f"https://www.bing.com/search?q={query.replace(' ', '+')}&setlang=tr&cc=TR"
                print(f"Bing Arama URL: {bing_url}")
                
                bing_response = requests.get(bing_url, headers=headers)
                print(f"Bing response status: {bing_response.status_code}")
                
                if bing_response.status_code == 200:
                    bing_soup = BeautifulSoup(bing_response.text, 'html.parser')
                    
                    # Bing sonuÃ§larÄ±nÄ± Ã§ek
                    bing_results = bing_soup.find_all('li', class_='b_algo')
                    print(f"Bing sonuÃ§ sayÄ±sÄ±: {len(bing_results)}")
                    
                    for result in bing_results[:5]:
                        try:
                            title_el = result.find('h2')
                            link_el = result.find('a')
                            desc_el = result.find('p')
                            
                            if title_el and link_el and desc_el:
                                title = title_el.text.strip()
                                link = link_el['href']
                                description = desc_el.text.strip()
                                
                                results.append({
                                    'title': title,
                                    'link': link,
                                    'description': description
                                })
                                print(f"Bing sonucu eklendi: {title}")
                        except Exception as e:
                            print(f"Bing sonuÃ§ ayrÄ±ÅŸtÄ±rma hatasÄ±: {e}")
            
            # Bing'de de sonuÃ§ bulunamazsa DuckDuckGo ile dene
            if not results:
                print("Bing'de sonuÃ§ bulunamadÄ±, DuckDuckGo deneniyor...")
                
                # 3. DuckDuckGo aramasÄ± (yedek)
                # TÃ¼rkÃ§e sonuÃ§lar iÃ§in bÃ¶lge parametresi ekle
                search_url = f"https://html.duckduckgo.com/html/?q={query.replace(' ', '+')} site:.tr&kl=tr-tr"
                print(f"DuckDuckGo Arama URL: {search_url}")
                
                response = requests.get(search_url, headers=headers)
                print(f"DuckDuckGo response status: {response.status_code}")
                
                if response.status_code == 200:
                    soup = BeautifulSoup(response.text, 'html.parser')
                    
                    # DuckDuckGo sonuÃ§larÄ±nÄ± Ã§ek
                    search_results = soup.find_all('div', class_='result')
                    print(f"Bulunan DuckDuckGo sonuÃ§ sayÄ±sÄ±: {len(search_results)}")
                    
                    for result in search_results[:5]:
                        try:
                            title_el = result.find('a', class_='result__a')
                            snippet_el = result.find('a', class_='result__snippet')
                            
                            if title_el and snippet_el:
                                title = title_el.text.strip()
                                link = title_el['href']
                                description = snippet_el.text.strip()
                                
                                # EÄŸer link baÅŸlangÄ±cÄ± "//" ise "https:" ekle
                                if link.startswith('//'):
                                    link = 'https:' + link
                                    
                                # EÄŸer link baÅŸlangÄ±cÄ± "http" deÄŸilse ve "//" ile baÅŸlamÄ±yorsa
                                elif not link.startswith(('http://', 'https://')):
                                    # DuckDuckGo yÃ¶nlendirme URL'sini temizle
                                    if '/l/?kh=' in link:
                                        # Link parametresini bul
                                        start_idx = link.find('uddg=')
                                        if start_idx != -1:
                                            start_idx += 5  # 'uddg=' uzunluÄŸu
                                            link = link[start_idx:]
                                            # URL decode
                                            import urllib.parse
                                            link = urllib.parse.unquote(link)
                                
                                results.append({
                                    'title': title,
                                    'link': link,
                                    'description': description
                                })
                                print(f"DuckDuckGo sonucu eklendi: {title}")
                        except Exception as e:
                            print(f"DuckDuckGo sonuÃ§ ayrÄ±ÅŸtÄ±rma hatasÄ±: {e}")
            
            return results
        except Exception as e:
            print(f"Arama iÅŸleminde hata: {str(e)}")
            # Hata durumunda boÅŸ liste dÃ¶ndÃ¼r ama hata fÄ±rlatma
            return []

    def check_and_run_file_command(self, text):
        """KullanÄ±cÄ± mesajÄ±nÄ± analiz eder ve dosya iÅŸlemi komutu varsa Ã§alÄ±ÅŸtÄ±rÄ±r"""
        # Ortak kullanÄ±lan klasÃ¶rlerin yollarÄ±
        common_folders = {
            "belgeler": os.path.join(os.path.expanduser("~"), "Documents"),
            "dÃ¶kÃ¼manlar": os.path.join(os.path.expanduser("~"), "Documents"),
            "dokÃ¼manlar": os.path.join(os.path.expanduser("~"), "Documents"),
            "documents": os.path.join(os.path.expanduser("~"), "Documents"),
            "indirilenler": os.path.join(os.path.expanduser("~"), "Downloads"),
            "downloads": os.path.join(os.path.expanduser("~"), "Downloads"),
            "masaÃ¼stÃ¼": os.path.join(os.path.expanduser("~"), "Desktop"),
            "desktop": os.path.join(os.path.expanduser("~"), "Desktop"),
            "resimler": os.path.join(os.path.expanduser("~"), "Pictures"),
            "pictures": os.path.join(os.path.expanduser("~"), "Pictures"),
            "mÃ¼zik": os.path.join(os.path.expanduser("~"), "Music"),
            "music": os.path.join(os.path.expanduser("~"), "Music"),
            "videolar": os.path.join(os.path.expanduser("~"), "Videos"),
            "videos": os.path.join(os.path.expanduser("~"), "Videos"),
        }
        
        # Debug mesajÄ±
        print(f"Dosya iÅŸlemi analiz ediliyor: '{text}'")
        print("Mevcut klasÃ¶r yollarÄ±:", common_folders)
        
        # KÃ¼Ã§Ã¼k harfe Ã§evir
        text_lower = text.lower()
        
        # Bir klasÃ¶rdeki tÃ¼m dosyalarÄ± taÅŸÄ±ma komutu
        if ("klasÃ¶rÃ¼ndeki" in text_lower or "iÃ§indeki" in text_lower) and "dosyalarÄ±" in text_lower and "taÅŸÄ±" in text_lower:
            print("Ã‡oklu dosya taÅŸÄ±ma komutu tespit edildi")
            
            # Kaynak ve hedef klasÃ¶rÃ¼ belirlemek iÃ§in pattern
            patterns = [
                r'(.*?)\s+klasÃ¶rÃ¼ndeki\s+dosyalarÄ±\s+(.*?)(?:\'a|\'e|e|a)\s+taÅŸÄ±',  # X klasÃ¶rÃ¼ndeki dosyalarÄ± Y'e taÅŸÄ±
                r'(.*?)\s+iÃ§indeki\s+dosyalarÄ±\s+(.*?)(?:\'a|\'e|e|a)\s+taÅŸÄ±',      # X iÃ§indeki dosyalarÄ± Y'e taÅŸÄ±
                r'(.*?)deki\s+dosyalarÄ±\s+(.*?)(?:\'a|\'e|e|a)\s+taÅŸÄ±',             # Xdeki dosyalarÄ± Y'e taÅŸÄ±
                r'(.*?)daki\s+dosyalarÄ±\s+(.*?)(?:\'a|\'e|e|a)\s+taÅŸÄ±',             # Xdaki dosyalarÄ± Y'e taÅŸÄ±
                r'(.*?)\s+(?:klasÃ¶rÃ¼nde|iÃ§inde)\s+bulunan\s+(?:tÃ¼m\s+)?dosyalarÄ±\s+(.*?)(?:\'a|\'e|e|a)\s+taÅŸÄ±'  # X klasÃ¶rÃ¼nde bulunan dosyalarÄ± Y'e taÅŸÄ±
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text_lower)
                if match:
                    print(f"Ã‡oklu dosya pattern eÅŸleÅŸti: {pattern}")
                    source = match.group(1).strip()
                    destination = match.group(2).strip()
                    print(f"EÅŸleÅŸen kaynak klasÃ¶r: {source}, hedef: {destination}")
                    
                    # Tam yol ise doÄŸrudan kullan, aksi takdirde ortak klasÃ¶rleri kontrol et
                    source_path = source
                    if ":\\" not in source and source in common_folders:
                        source_path = common_folders[source]
                    
                    dest_path = destination
                    if destination in common_folders:
                        dest_path = common_folders[destination]
                    
                    return self.move_all_files(source_path, dest_path)
        
        # BasitleÅŸtirilmiÅŸ dosya taÅŸÄ±ma komutu
        if "dosya" in text_lower and "taÅŸÄ±" in text_lower:
            print("Dosya taÅŸÄ±ma komutu tespit edildi")
            
            # Ä°ndirilenler/Downloads klasÃ¶rÃ¼nden bir dosyayÄ± belgeler/documents klasÃ¶rÃ¼ne taÅŸÄ±ma
            if ("indir" in text_lower or "download" in text_lower) and ("belge" in text_lower or "dokÃ¼" in text_lower or "document" in text_lower):
                # Dosya adÄ±nÄ± bul
                for word in text_lower.split():
                    if "." in word:  # Muhtemelen dosya adÄ± (uzantÄ±sÄ± var)
                        source = word
                        print(f"Muhtemel dosya adÄ±: {source}")
                        
                        # Kaynak klasÃ¶rÃ¼ belirle (Downloads)
                        source_folder = common_folders.get("downloads", os.path.join(os.path.expanduser("~"), "Downloads"))
                        
                        # Hedef klasÃ¶rÃ¼ belirle (Documents)
                        dest_folder = common_folders.get("documents", os.path.join(os.path.expanduser("~"), "Documents"))
                        
                        return self.move_file(os.path.join(source_folder, source), dest_folder, common_folders)
            
            # DiÄŸer taÅŸÄ±ma komutlarÄ± iÃ§in dÃ¼zenli ifadeleri deneyelim
            # BasitleÅŸtirilmiÅŸ regex pattern'ler
            patterns = [
                r'([\w\.]+)\s+dosyasÄ±nÄ±\s+([\w]+)(?:\'e|\'a|a|e)\s+taÅŸÄ±',  # X dosyasÄ±nÄ± Y'e taÅŸÄ±
                r'([\w\.]+)(?:\'i|i)\s+([\w]+)(?:\'e|\'a|a|e)\s+taÅŸÄ±',     # X'i Y'e taÅŸÄ±
                r'taÅŸÄ±\s+([\w\.]+)(?:\'i|i)?\s+([\w]+)(?:\'e|\'a|a|e)?'    # taÅŸÄ± X'i Y'e
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text_lower)
                if match:
                    print(f"Pattern eÅŸleÅŸti: {pattern}")
                    source = match.group(1).strip()
                    destination = match.group(2).strip()
                    print(f"EÅŸleÅŸen kaynak: {source}, hedef: {destination}")
                    return self.move_file(source, destination, common_folders)
        
        # Dosya kopyalama komutu (basitleÅŸtirilmiÅŸ)
        if "kopyala" in text_lower:
            print("Dosya kopyalama komutu tespit edildi")
            patterns = [
                r'([\w\.]+)\s+dosyasÄ±nÄ±\s+([\w]+)(?:\'e|\'a|a|e)\s+kopyala',  # X dosyasÄ±nÄ± Y'e kopyala
                r'([\w\.]+)(?:\'i|i)\s+([\w]+)(?:\'e|\'a|a|e)\s+kopyala',     # X'i Y'e kopyala
                r'kopyala\s+([\w\.]+)(?:\'i|i)?\s+([\w]+)(?:\'e|\'a|a|e)?'    # kopyala X'i Y'e
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text_lower)
                if match:
                    print(f"Pattern eÅŸleÅŸti: {pattern}")
                    source = match.group(1).strip()
                    destination = match.group(2).strip()
                    print(f"EÅŸleÅŸen kaynak: {source}, hedef: {destination}")
                    return self.copy_file(source, destination, common_folders)
        
        # Dosya silme komutu (basitleÅŸtirilmiÅŸ)
        if "sil" in text_lower:
            print("Dosya silme komutu tespit edildi")
            patterns = [
                r'([\w\.]+)\s+dosyasÄ±nÄ±\s+sil',  # X dosyasÄ±nÄ± sil
                r'([\w\.]+)(?:\'i|i)\s+sil',     # X'i sil
                r'sil\s+([\w\.]+)'               # sil X
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text_lower)
                if match:
                    print(f"Pattern eÅŸleÅŸti: {pattern}")
                    source = match.group(1).strip()
                    print(f"EÅŸleÅŸen dosya: {source}")
                    return self.delete_file(source, common_folders)
        
        print("Dosya iÅŸlemi komutu tespit edilemedi")
        return False  # Dosya iÅŸlemi komutu deÄŸil
    
    def move_all_files(self, source_dir, dest_dir):
        """Bir klasÃ¶rdeki tÃ¼m dosyalarÄ± baÅŸka bir klasÃ¶re taÅŸÄ±r"""
        try:
            # Debug mesajlarÄ±
            print(f"TÃ¼m dosyalarÄ± taÅŸÄ±ma iÅŸlemi baÅŸlatÄ±ldÄ±")
            print(f"Kaynak klasÃ¶r: {source_dir}")
            print(f"Hedef klasÃ¶r: {dest_dir}")
            
            # Bilgi mesajÄ±
            info_message = ChatMessage(f"ğŸ”„ KlasÃ¶r taÅŸÄ±ma iÅŸlemi: \"{source_dir}\" klasÃ¶rÃ¼ndeki tÃ¼m dosyalar â†’ \"{dest_dir}\"", is_user=False)
            self.messages_layout.addWidget(info_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            
            # Kaynak klasÃ¶rÃ¼n var olup olmadÄ±ÄŸÄ±nÄ± kontrol et
            if not os.path.exists(source_dir) or not os.path.isdir(source_dir):
                print(f"Kaynak klasÃ¶r bulunamadÄ±: {source_dir}")
                not_found = ChatMessage(f"âŒ Kaynak klasÃ¶r bulunamadÄ±: {source_dir}", is_user=False)
                self.messages_layout.addWidget(not_found)
                return True
            
            # Hedef klasÃ¶rÃ¼n var olup olmadÄ±ÄŸÄ±nÄ± kontrol et
            if not os.path.exists(dest_dir):
                print(f"Hedef klasÃ¶r bulunamadÄ±, oluÅŸturuluyor: {dest_dir}")
                os.makedirs(dest_dir)
            
            # KlasÃ¶rdeki tÃ¼m dosyalarÄ± listele
            files = [f for f in os.listdir(source_dir) if os.path.isfile(os.path.join(source_dir, f))]
            
            if not files:
                print(f"Kaynak klasÃ¶rde dosya bulunamadÄ±: {source_dir}")
                no_files = ChatMessage(f"âš ï¸ Kaynak klasÃ¶rde taÅŸÄ±nacak dosya bulunamadÄ±: {source_dir}", is_user=False)
                self.messages_layout.addWidget(no_files)
                return True
            
            # DosyalarÄ± taÅŸÄ±
            moved_count = 0
            for file in files:
                source_path = os.path.join(source_dir, file)
                dest_path = os.path.join(dest_dir, file)
                
                # EÄŸer hedefte aynÄ± isimde dosya varsa, Ã¼zerine yazÄ±lacak mÄ± diye sor
                if os.path.exists(dest_path):
                    print(f"Hedefte aynÄ± isimde dosya var: {dest_path}")
                    overwrite = QMessageBox.question(
                        self,
                        "Dosya Zaten Var",
                        f"Hedefte aynÄ± isimde dosya var: {file}\nÃœzerine yazmak istiyor musunuz?",
                        QMessageBox.Yes | QMessageBox.No
                    )
                    
                    if overwrite == QMessageBox.No:
                        print(f"Dosya atlandÄ±: {file}")
                        continue
                
                try:
                    print(f"Dosya taÅŸÄ±nÄ±yor: {source_path} -> {dest_path}")
                    shutil.move(source_path, dest_path)
                    moved_count += 1
                except Exception as e:
                    print(f"Dosya taÅŸÄ±ma hatasÄ± ({file}): {str(e)}")
            
            # BaÅŸarÄ± mesajÄ±
            success_message = ChatMessage(f"âœ… {moved_count} dosya baÅŸarÄ±yla taÅŸÄ±ndÄ±:\n{source_dir} â†’ {dest_dir}", is_user=False)
            self.messages_layout.addWidget(success_message)
            return True
            
        except Exception as e:
            print(f"Ã‡oklu dosya taÅŸÄ±ma hatasÄ±: {str(e)}")
            error_message = ChatMessage(f"âŒ DosyalarÄ± taÅŸÄ±rken bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
            return True  # Komutu iÅŸlenmiÅŸ olarak kabul et
    
    def resolve_path(self, path, common_folders):
        """KullanÄ±cÄ±nÄ±n belirttiÄŸi dosya/klasÃ¶r yolunu Ã§Ã¶zÃ¼mler"""
        path = path.strip().lower()
        
        # EÄŸer 'klasÃ¶rÃ¼ndeki', 'iÃ§indeki' gibi ifadeler varsa, klasÃ¶r ve dosya adÄ±nÄ± ayÄ±rÄ±r
        folder_file_patterns = [
            r'(.*?)\s+klasÃ¶rÃ¼ndeki\s+(.*)',
            r'(.*?)\s+dizinindeki\s+(.*)',
            r'(.*?)\s+konumundaki\s+(.*)',
            r'(.*?)\s+iÃ§indeki\s+(.*)',
            r'(.*?)(?:\'deki|deki)\s+(.*)',
            r'(.*?)(?:\'daki|daki)\s+(.*)',
        ]
        
        for pattern in folder_file_patterns:
            match = re.search(pattern, path)
            if match:
                folder = match.group(1).strip()
                file = match.group(2).strip()
                
                # KlasÃ¶r yolunu Ã§Ã¶zÃ¼mle
                folder_path = None
                if folder in common_folders:
                    folder_path = common_folders[folder]
                elif folder.startswith("c:") or folder.startswith("/"):
                    folder_path = folder  # Tam yol zaten belirtilmiÅŸ
                
                if folder_path and file:
                    return os.path.join(folder_path, file)
        
        # Bilinen klasÃ¶r adlarÄ±nÄ± kontrol et
        if path in common_folders:
            return common_folders[path]
        
        # Tam yol olarak dÃ¶n
        return path
    
    def move_file(self, source, destination, common_folders):
        """DosyayÄ± bir konumdan diÄŸerine taÅŸÄ±r"""
        try:
            # Debug mesajlarÄ±
            print(f"Dosya taÅŸÄ±ma iÅŸlemi baÅŸlatÄ±ldÄ±")
            print(f"Kaynak: {source}")
            print(f"Hedef: {destination}")
            
            # Bilgi mesajÄ±
            info_message = ChatMessage(f"ğŸ”„ Dosya taÅŸÄ±ma iÅŸlemi: \"{source}\" â†’ \"{destination}\"", is_user=False)
            self.messages_layout.addWidget(info_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            
            # Kaynak ve hedef yollarÄ± Ã§Ã¶zÃ¼mle
            source_path = self.resolve_path(source, common_folders)
            dest_path = self.resolve_path(destination, common_folders)
            
            print(f"Ã‡Ã¶zÃ¼mlenen kaynak yolu: {source_path}")
            print(f"Ã‡Ã¶zÃ¼mlenen hedef yolu: {dest_path}")
            
            # EÄŸer hedef bir klasÃ¶rse, dosya adÄ±nÄ± koruyarak o klasÃ¶re taÅŸÄ±
            if os.path.isdir(dest_path):
                filename = os.path.basename(source_path)
                dest_path = os.path.join(dest_path, filename)
                print(f"Hedef klasÃ¶r, tam hedef yolu: {dest_path}")
            
            # Kaynak dosyanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± kontrol et
            if not os.path.exists(source_path):
                print(f"Kaynak dosya bulunamadÄ±: {source_path}")
                not_found = ChatMessage(f"âŒ Kaynak dosya bulunamadÄ±: {source_path}", is_user=False)
                self.messages_layout.addWidget(not_found)
                return True
            
            # DosyayÄ± taÅŸÄ±
            print(f"Dosya taÅŸÄ±nÄ±yor: {source_path} -> {dest_path}")
            shutil.move(source_path, dest_path)
            print("Dosya baÅŸarÄ±yla taÅŸÄ±ndÄ±")
            
            # BaÅŸarÄ± mesajÄ±
            success_message = ChatMessage(f"âœ… Dosya baÅŸarÄ±yla taÅŸÄ±ndÄ±:\n{source_path} â†’ {dest_path}", is_user=False)
            self.messages_layout.addWidget(success_message)
            return True
            
        except Exception as e:
            print(f"Dosya taÅŸÄ±ma hatasÄ±: {str(e)}")
            error_message = ChatMessage(f"âŒ Dosya taÅŸÄ±ma iÅŸlemi sÄ±rasÄ±nda bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
            return True  # Komutu iÅŸlenmiÅŸ olarak kabul et
    
    def copy_file(self, source, destination, common_folders):
        """DosyayÄ± bir konumdan diÄŸerine kopyalar"""
        try:
            # Bilgi mesajÄ±
            info_message = ChatMessage(f"ğŸ“‹ Dosya kopyalama iÅŸlemi: \"{source}\" â†’ \"{destination}\"", is_user=False)
            self.messages_layout.addWidget(info_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            
            # Kaynak ve hedef yollarÄ± Ã§Ã¶zÃ¼mle
            source_path = self.resolve_path(source, common_folders)
            dest_path = self.resolve_path(destination, common_folders)
            
            # EÄŸer hedef bir klasÃ¶rse, dosya adÄ±nÄ± koruyarak o klasÃ¶re kopyala
            if os.path.isdir(dest_path):
                filename = os.path.basename(source_path)
                dest_path = os.path.join(dest_path, filename)
            
            # Kaynak dosyanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± kontrol et
            if not os.path.exists(source_path):
                not_found = ChatMessage(f"âŒ Kaynak dosya bulunamadÄ±: {source_path}", is_user=False)
                self.messages_layout.addWidget(not_found)
                return True
            
            # DosyayÄ± kopyala
            if os.path.isdir(source_path):
                shutil.copytree(source_path, dest_path)
            else:
                shutil.copy2(source_path, dest_path)
            
            # BaÅŸarÄ± mesajÄ±
            success_message = ChatMessage(f"âœ… Dosya baÅŸarÄ±yla kopyalandÄ±:\n{source_path} â†’ {dest_path}", is_user=False)
            self.messages_layout.addWidget(success_message)
            return True
            
        except Exception as e:
            error_message = ChatMessage(f"âŒ Dosya kopyalama iÅŸlemi sÄ±rasÄ±nda bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
            return True  # Komutu iÅŸlenmiÅŸ olarak kabul et
    
    def delete_file(self, source, common_folders):
        """DosyayÄ± siler"""
        try:
            # Bilgi mesajÄ±
            info_message = ChatMessage(f"ğŸ—‘ï¸ Dosya silme iÅŸlemi: \"{source}\"", is_user=False)
            self.messages_layout.addWidget(info_message)
            
            # Otomatik olarak en aÅŸaÄŸÄ±ya kaydÄ±r
            QApplication.processEvents()
            
            # Kaynak yolu Ã§Ã¶zÃ¼mle
            source_path = self.resolve_path(source, common_folders)
            
            # Kaynak dosyanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± kontrol et
            if not os.path.exists(source_path):
                not_found = ChatMessage(f"âŒ Silinecek dosya bulunamadÄ±: {source_path}", is_user=False)
                self.messages_layout.addWidget(not_found)
                return True
            
            # Silme iÅŸlemi iÃ§in onay iste
            confirm = QMessageBox.question(
                self,
                "Dosya Silme OnayÄ±",
                f"Bu dosya/klasÃ¶rÃ¼ silmek istediÄŸinizden emin misiniz?\n{source_path}",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if confirm == QMessageBox.Yes:
                # Dosya veya klasÃ¶rÃ¼ sil
                if os.path.isdir(source_path):
                    shutil.rmtree(source_path)
                else:
                    os.remove(source_path)
                
                # BaÅŸarÄ± mesajÄ±
                success_message = ChatMessage(f"âœ… Dosya baÅŸarÄ±yla silindi: {source_path}", is_user=False)
                self.messages_layout.addWidget(success_message)
            else:
                # Ä°ptal mesajÄ±
                cancel_message = ChatMessage("âŒ Dosya silme iÅŸlemi iptal edildi.", is_user=False)
                self.messages_layout.addWidget(cancel_message)
                
            return True
            
        except Exception as e:
            error_message = ChatMessage(f"âŒ Dosya silme iÅŸlemi sÄ±rasÄ±nda bir hata oluÅŸtu: {str(e)}", is_user=False)
            self.messages_layout.addWidget(error_message)
            return True  # Komutu iÅŸlenmiÅŸ olarak kabul et

    def check_and_run_scheduled_task_command(self, text):
        text_lower = text.lower()
        
        # Hemen bilgisayarÄ± kapatma komutu
        if any(x in text_lower for x in ["pcyi kapat", "pc'yi kapat", "bilgisayarÄ± kapat"]) and not any(x in text_lower for x in ["dakika", "saat"]):
            # GÃ¶revi hemen ekle
            self.task_manager.add_immediate_task(
                0,  # Hemen
                "shutdown",
                {"delay": 10}  # 10 saniye uyarÄ± sÃ¼resi
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            success_msg = ChatMessage(
                "âœ… BilgisayarÄ± kapatÄ±yorum (10 saniye iÃ§inde)", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True
        
        # Hemen/kÄ±sa sÃ¼reli gÃ¶revler iÃ§in regex
        immediate_shutdown_pattern = r"(\d+)\s+(?:dakika|dk)\s+sonra\s+(?:bilgisayarÄ±|pc'yi|pc yi|bilgisayarÄ±mÄ±)\s+(?:kapat|shutdown|kapa)"
        immediate_restart_pattern = r"(\d+)\s+(?:dakika|dk)\s+sonra\s+(?:bilgisayarÄ±|pc'yi|pc yi|bilgisayarÄ±mÄ±)\s+(?:yeniden\s+baÅŸlat|restart|reset)"
        immediate_reminder_pattern = r"(\d+)\s+(?:dakika|dk)\s+sonra\s+(?:bana)?\s+(.+?)\s+(?:hatÄ±rlat|hatÄ±rlatÄ±r mÄ±sÄ±n)"
        
        # Hemen/kÄ±sa sÃ¼reli bilgisayarÄ± kapatma gÃ¶revi
        immediate_shutdown_match = re.search(immediate_shutdown_pattern, text_lower)
        if immediate_shutdown_match:
            delay = int(immediate_shutdown_match.group(1))
            
            # GÃ¶revi ekle
            self.task_manager.add_immediate_task(
                delay,
                "shutdown",
                {"delay": 60}  # 60 saniye uyarÄ± sÃ¼resi
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            success_msg = ChatMessage(
                f"âœ… {delay} dakika sonra bilgisayarÄ± kapatacaÄŸÄ±m.", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True
        
        # Hemen/kÄ±sa sÃ¼reli bilgisayarÄ± yeniden baÅŸlatma gÃ¶revi
        immediate_restart_match = re.search(immediate_restart_pattern, text_lower)
        if immediate_restart_match:
            delay = int(immediate_restart_match.group(1))
            
            # GÃ¶revi ekle
            self.task_manager.add_immediate_task(
                delay,
                "restart",
                {"delay": 60}  # 60 saniye uyarÄ± sÃ¼resi
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            success_msg = ChatMessage(
                f"âœ… {delay} dakika sonra bilgisayarÄ± yeniden baÅŸlatacaÄŸÄ±m.", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True
        
        # Hemen/kÄ±sa sÃ¼reli hatÄ±rlatÄ±cÄ± gÃ¶revi
        immediate_reminder_match = re.search(immediate_reminder_pattern, text_lower)
        if immediate_reminder_match:
            delay = int(immediate_reminder_match.group(1))
            reminder_message = immediate_reminder_match.group(2).strip()
            
            # GÃ¶revi ekle
            self.task_manager.add_immediate_task(
                delay,
                "reminder",
                {"message": f"â° HATIRLATICI: {reminder_message}"}
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            success_msg = ChatMessage(
                f"âœ… {delay} dakika sonra size '{reminder_message}' hatÄ±rlatacaÄŸÄ±m.", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True

        # GÃ¶rev ekleme komutlarÄ± iÃ§in regex
        shutdown_pattern = r"(her\s+gÃ¼n|hafta\s+iÃ§i|hafta\s+sonu|pazartesi|salÄ±|Ã§arÅŸamba|perÅŸembe|cuma|cumartesi|pazar)\s+saat\s+(\d{1,2})[:\.]?(\d{0,2})\s+(?:da|de)?\s+(bilgisayarÄ±|pc'yi|pc yi|bilgisayarÄ±mÄ±)\s+(kapat|shutdown|kapa)"
        
        restart_pattern = r"(her\s+gÃ¼n|hafta\s+iÃ§i|hafta\s+sonu|pazartesi|salÄ±|Ã§arÅŸamba|perÅŸembe|cuma|cumartesi|pazar)\s+saat\s+(\d{1,2})[:\.]?(\d{0,2})\s+(?:da|de)?\s+(bilgisayarÄ±|pc'yi|pc yi|bilgisayarÄ±mÄ±)\s+(yeniden\s+baÅŸlat|restart|reset)"
        
        reminder_pattern = r"(her\s+gÃ¼n|hafta\s+iÃ§i|hafta\s+sonu|pazartesi|salÄ±|Ã§arÅŸamba|perÅŸembe|cuma|cumartesi|pazar)\s+saat\s+(\d{1,2})[:\.]?(\d{0,2})\s+(?:da|de)?\s+(?:bana)?\s+(.+?)\s+(?:hatÄ±rlat|hatÄ±rlatÄ±r mÄ±sÄ±n)"
        
        # BilgisayarÄ± kapatma gÃ¶revi ekle
        shutdown_match = re.search(shutdown_pattern, text_lower)
        if shutdown_match:
            repeat = shutdown_match.group(1).strip()
            hour = int(shutdown_match.group(2))
            minute = int(shutdown_match.group(3)) if shutdown_match.group(3) else 0
            time_str = f"{hour:02d}:{minute:02d}"
            
            # Tekrarlama tipini belirle
            repeat_type = "daily"  # VarsayÄ±lan: her gÃ¼n
            if repeat == "hafta iÃ§i":
                repeat_type = "weekdays"
            elif repeat == "hafta sonu":
                repeat_type = "weekends"
            elif repeat in ["pazartesi", "salÄ±", "Ã§arÅŸamba", "perÅŸembe", "cuma", "cumartesi", "pazar"]:
                repeat_type = repeat
            
            # GÃ¶revi ekle
            task_id = self.task_manager.add_task(
                time_str, 
                "shutdown", 
                {"delay": 60},  # 60 saniye sonra kapat
                repeat_type
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            repeat_msg = {
                "daily": "Her gÃ¼n",
                "weekdays": "Hafta iÃ§i her gÃ¼n",
                "weekends": "Hafta sonu her gÃ¼n",
                "pazartesi": "Her Pazartesi",
                "salÄ±": "Her SalÄ±",
                "Ã§arÅŸamba": "Her Ã‡arÅŸamba",
                "perÅŸembe": "Her PerÅŸembe",
                "cuma": "Her Cuma",
                "cumartesi": "Her Cumartesi",
                "pazar": "Her Pazar"
            }.get(repeat_type, repeat_type)
            
            success_msg = ChatMessage(
                f"âœ… ZamanlanmÄ±ÅŸ gÃ¶rev eklendi: {repeat_msg} saat {time_str}'de bilgisayarÄ± kapatacaÄŸÄ±m.", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True
        
        # BilgisayarÄ± yeniden baÅŸlatma gÃ¶revi ekle
        restart_match = re.search(restart_pattern, text_lower)
        if restart_match:
            repeat = restart_match.group(1).strip()
            hour = int(restart_match.group(2))
            minute = int(restart_match.group(3)) if restart_match.group(3) else 0
            time_str = f"{hour:02d}:{minute:02d}"
            
            # Tekrarlama tipini belirle
            repeat_type = "daily"  # VarsayÄ±lan: her gÃ¼n
            if repeat == "hafta iÃ§i":
                repeat_type = "weekdays"
            elif repeat == "hafta sonu":
                repeat_type = "weekends"
            elif repeat in ["pazartesi", "salÄ±", "Ã§arÅŸamba", "perÅŸembe", "cuma", "cumartesi", "pazar"]:
                repeat_type = repeat
            
            # GÃ¶revi ekle
            task_id = self.task_manager.add_task(
                time_str, 
                "restart", 
                {"delay": 60},  # 60 saniye sonra yeniden baÅŸlat
                repeat_type
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            repeat_msg = {
                "daily": "Her gÃ¼n",
                "weekdays": "Hafta iÃ§i her gÃ¼n",
                "weekends": "Hafta sonu her gÃ¼n",
                "pazartesi": "Her Pazartesi",
                "salÄ±": "Her SalÄ±",
                "Ã§arÅŸamba": "Her Ã‡arÅŸamba",
                "perÅŸembe": "Her PerÅŸembe",
                "cuma": "Her Cuma",
                "cumartesi": "Her Cumartesi",
                "pazar": "Her Pazar"
            }.get(repeat_type, repeat_type)
            
            success_msg = ChatMessage(
                f"âœ… ZamanlanmÄ±ÅŸ gÃ¶rev eklendi: {repeat_msg} saat {time_str}'de bilgisayarÄ± yeniden baÅŸlatacaÄŸÄ±m.", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True
        
        # HatÄ±rlatÄ±cÄ± gÃ¶revi ekle
        reminder_match = re.search(reminder_pattern, text_lower)
        if reminder_match:
            repeat = reminder_match.group(1).strip()
            hour = int(reminder_match.group(2))
            minute = int(reminder_match.group(3)) if reminder_match.group(3) else 0
            reminder_message = reminder_match.group(4).strip()
            time_str = f"{hour:02d}:{minute:02d}"
            
            # Tekrarlama tipini belirle
            repeat_type = "daily"  # VarsayÄ±lan: her gÃ¼n
            if repeat == "hafta iÃ§i":
                repeat_type = "weekdays"
            elif repeat == "hafta sonu":
                repeat_type = "weekends"
            elif repeat in ["pazartesi", "salÄ±", "Ã§arÅŸamba", "perÅŸembe", "cuma", "cumartesi", "pazar"]:
                repeat_type = repeat
            
            # GÃ¶revi ekle
            task_id = self.task_manager.add_task(
                time_str, 
                "reminder", 
                {"message": f"â° HATIRLATICI: {reminder_message}"},
                repeat_type
            )
            
            # KullanÄ±cÄ±ya bilgi ver
            repeat_msg = {
                "daily": "Her gÃ¼n",
                "weekdays": "Hafta iÃ§i her gÃ¼n",
                "weekends": "Hafta sonu her gÃ¼n",
                "pazartesi": "Her Pazartesi",
                "salÄ±": "Her SalÄ±",
                "Ã§arÅŸamba": "Her Ã‡arÅŸamba",
                "perÅŸembe": "Her PerÅŸembe",
                "cuma": "Her Cuma",
                "cumartesi": "Her Cumartesi",
                "pazar": "Her Pazar"
            }.get(repeat_type, repeat_type)
            
            success_msg = ChatMessage(
                f"âœ… HatÄ±rlatÄ±cÄ± eklendi: {repeat_msg} saat {time_str}'de size '{reminder_message}' hatÄ±rlatacaÄŸÄ±m.", 
                is_user=False
            )
            self.messages_layout.addWidget(success_msg)
            return True
        
        # GÃ¶rev listeleme komutu
        if "gÃ¶revleri listele" in text_lower or "zamanlanmÄ±ÅŸ gÃ¶revler" in text_lower or "gÃ¶revlerimi gÃ¶ster" in text_lower:
            tasks = self.task_manager.tasks
            
            if not tasks:
                no_tasks_msg = ChatMessage("HenÃ¼z zamanlanmÄ±ÅŸ gÃ¶rev bulunmuyor.", is_user=False)
                self.messages_layout.addWidget(no_tasks_msg)
            else:
                tasks_text = "ğŸ“… ZamanlanmÄ±ÅŸ GÃ¶revler:\n\n"
                for i, task in enumerate(tasks):
                    action_name = {
                        "shutdown": "BilgisayarÄ± Kapat",
                        "restart": "BilgisayarÄ± Yeniden BaÅŸlat",
                        "reminder": "HatÄ±rlatÄ±cÄ±",
                        "run_app": "Uygulama Ã‡alÄ±ÅŸtÄ±r"
                    }.get(task["action"], task["action"])
                    
                    repeat_name = {
                        "daily": "Her gÃ¼n",
                        "weekdays": "Hafta iÃ§i",
                        "weekends": "Hafta sonu",
                        "pazartesi": "Her Pazartesi",
                        "salÄ±": "Her SalÄ±",
                        "Ã§arÅŸamba": "Her Ã‡arÅŸamba",
                        "perÅŸembe": "Her PerÅŸembe",
                        "cuma": "Her Cuma",
                        "cumartesi": "Her Cumartesi",
                        "pazar": "Her Pazar"
                    }.get(task["repeat"], task["repeat"])
                    
                    # GÃ¶rev detaylarÄ±
                    details = ""
                    if task["action"] == "reminder":
                        details = f" - \"{task['parameters'].get('message', '')}\""
                    
                    tasks_text += f"{i+1}. {repeat_name} saat {task['time']} - {action_name}{details}\n"
                
                tasks_msg = ChatMessage(tasks_text, is_user=False)
                self.messages_layout.addWidget(tasks_msg)
            return True
        
        # GÃ¶rev silme komutu
        if "gÃ¶revi sil" in text_lower or "gÃ¶revini sil" in text_lower:
            # GÃ¶rev numarasÄ±nÄ± bul
            task_num_pattern = r"(\d+)[.\s]*(?:numaralÄ±)?\s+gÃ¶rev"
            task_num_match = re.search(task_num_pattern, text_lower)
            
            if task_num_match:
                task_num = int(task_num_match.group(1))
                task_id = task_num - 1  # KullanÄ±cÄ± 1'den baÅŸlayarak sayÄ±yor, indeks 0'dan
                
                if self.task_manager.delete_task(task_id):
                    success_msg = ChatMessage(f"âœ… {task_num} numaralÄ± gÃ¶rev silindi.", is_user=False)
                    self.messages_layout.addWidget(success_msg)
                else:
                    error_msg = ChatMessage(f"âŒ {task_num} numaralÄ± gÃ¶rev bulunamadÄ±.", is_user=False)
                    self.messages_layout.addWidget(error_msg)
                return True
        
        return False  # ZamanlanmÄ±ÅŸ gÃ¶rev komutu deÄŸil

    def update_discord_status(self, details, state=None):
        """Discord durumunu gÃ¼nceller"""
        if self.rpc:
            try:
                self.rpc.update(
                    details=details,
                    state=state,
                    large_image="tai_logo",  # Discord uygulamanÄ±za yÃ¼klediÄŸiniz resmin adÄ±
                    large_text="TAI - TÃ¼rkÃ§e Yapay Zeka AsistanÄ±",
                    start=int(time.time())  # Aktivite baÅŸlangÄ±Ã§ zamanÄ±
                )
            except Exception as e:
                print(f"Discord durumu gÃ¼ncellenemedi: {e}")

if __name__ == '__main__':
    # QMessageBox stilini Ã¶zelleÅŸtir
    qss = """
        QMessageBox {
            background-color: #282a36;
            color: white;
            font-family: 'Segoe UI', 'Arial';
        }
        QMessageBox QLabel {
            color: white;
        }
        QMessageBox QPushButton {
            background-color: #6272a4;
            color: white;
            border-radius: 5px;
            padding: 8px 16px;
            min-width: 80px;
        }
        QMessageBox QPushButton:hover {
            background-color: #7282b4;
        }
    """
    
    app = QApplication(sys.argv)
    app.setStyleSheet(qss)  # MessageBox stili uygula
    ex = App()
    ex.show()
    sys.exit(app.exec_())
